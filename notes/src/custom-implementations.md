## Popular Java LLD questions solution

### Index
|Custom Java Implementations|Custom Data Structures Implementations|
|---|---|
|[Custom Connection Pool](#custom-connection-pool)|[LRU Cache](#lru-cache)|
|[Custom ThreadPool](#custom-threadpool)|[HashMap](#hashmap)|
|[Custom ThreadPoolExecutor](#custom-threadpoolexecutor)|[LFU Cache](#lfu-cache)|
|[Custom CountDownLatch](#custom-countdownlatch)|[Min Stack](#min-stack)|
|[Custom CyclicBarrier](#custom-cyclicbarrier)|[Stack Using Queues](#stack-using-queues)|
|[Custom Semaphore](#custom-semaphore)|[Queue Using Stack](#queue-using-stack)|
|[Custom ReentrantLock](#custom-reentrantlock)|[Custom ArrayList](#custom-arraylist)|
|[Custom ReentrantReadWriteLock](#custom-reentrantreadwritelock)|[Custom BlockingQueue](#custom-blockingqueue)|
|[Producer Consumer BlockingQueue](#producer-consumer-blockingqueue)|[Custom Dequeue](#custom-dequeue)|
|[Producer Consumer WaitNotify](#producer-consumer-waitnotify)|[Custom HashSet](#custom-hashset)|
||[Custom LinkedHashMap](#custom-linkedhashmap)|


### Source Code Links

|Custom Java Implementations|Custom Data Structures Implementations|
|---|---|
|[Custom Connection Pool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/customConnectionPool/BasicConnectionPool.java)|[LRU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LRUCache146_V2.java)|
|[Custom ThreadPool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPool.java)|[HashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/DesignHashMap706.java)|
|[Custom ThreadPoolExecutor](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPoolExecutor.java)|[LFU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LFUCache460_V2.java)|
|[Custom CountDownLatch](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CountdownLatchCustom.java)|[Min Stack](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/MinStack155.java)|
|[Custom CyclicBarrier](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CyclicBarrierCustom.java)|[Stack Using Queues](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/StackUsingQueues_225.java)|
|[Custom Semaphore](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/SemaphoreCustom.java)|[Queue Using Stack](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/QueueUsingStack_232.java)|
|[Custom ReentrantLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantLockCustom.java)|[Custom ArrayList](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ArrayListCustom.java)|
|[Custom ReentrantReadWriteLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantReadWriteLock.java)|[Custom BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/BlockingQueueCustomTest.java)|
|[Producer Consumer BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerBlockingQueue.java)|[Custom Dequeue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomDequeue.java)|
|[Producer Consumer WaitNotify](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerWaitNotify.java)|[Custom HashSet](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomHashSet.java)|
||[Custom LinkedHashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomLinkedHashMap.java)|

### Link to Custom Java Implementations              
- [Custom Connection Pool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/customConnectionPool/BasicConnectionPool.java)                              
- [Custom ThreadPool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPool.java)             
- [Custom ThreadPoolExecutor](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPoolExecutor.java)             
- [Custom CountDownLatch](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CountdownLatchCustom.java)             
- [Custom CyclicBarrier](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CyclicBarrierCustom.java)              
- [Custom Semaphore](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/SemaphoreCustom.java)                  
- [Custom ReentrantLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantLockCustom.java)              
- [Custom ReentrantReadWriteLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantReadWriteLock.java)                     
- [Producer Consumer BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerBlockingQueue.java)               
- [Producer Consumer WaitNotify](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerWaitNotify.java)                  

               
### Link to Custom Data Structures Implementations        
- [LRU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LRUCache146_V2.java)                         
- [HashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/DesignHashMap706.java)                           
- [LFU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LFUCache460_V2.java)         
- [Min Stack](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/MinStack155.java)         
- [Stack Using Queues](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/StackUsingQueues_225.java)            
- [Queue Using Stack](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/QueueUsingStack_232.java)                
- [Custom ArrayList](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ArrayListCustom.java)                          
- [Custom BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/BlockingQueueCustomTest.java)          
- [Custom Dequeue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomDequeue.java)            
- [Custom HashSet](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomHashSet.java)                
- [Custom LinkedHashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomLinkedHashMap.java)                          
- [Custom LinkedHashSet](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomLinkedHashSet.java)                          
     
     
### Custom Semaphore                
### Custom ReentrantLock                
### Custom ReentrantReadWriteLock               
### Producer Consumer BlockingQueue             
### Producer Consumer WaitNotify                
                    
### LRU Cache               
### HashMap             
### LFU Cache               
### Min Stack               
### Stack Using Queues              
### Queue Using Stack               
### Custom ArrayList                
### Custom BlockingQueue                
### Custom Dequeue              
### Custom HashSet              
### Custom LinkedHashMap                
### Custom LinkedHashSet                
       
### Custom Connection Pool          
- [Custom Connection Pool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/customConnectionPool/BasicConnectionPool.java)               


        interface IConnectionPool {
            Connection getConnection();
            boolean releaseConnection(Connection connection);
            String getUrl();
            String getUser();
            String getPassword();
        }
        
        public class BasicConnectionPool implements IConnectionPool {
            private String url;
            private String user;
            private String password;
            private List<Connection> connectionPool;
            private List<Connection> usedConnections = new ArrayList<>();
            private static int INITIAL_POOL_SIZE = 10;
            private static int MAX_POOL_SIZE = 20;
            private static int MAX_TIMEOUT = 60;
        
            private BasicConnectionPool(String url, String user, String password, List<Connection> connectionPool) {
                this.url = url;
                this.user = user;
                this.password = password;
                this.connectionPool = connectionPool;
            }
        
            public static BasicConnectionPool create(String url, String user, String password) throws SQLException {
                List<Connection> pool = new ArrayList<>(INITIAL_POOL_SIZE);
                for (int i = 0; i < INITIAL_POOL_SIZE; i++) {
                    pool.add(createConnection(url, user, password));
                }
                return new BasicConnectionPool(url, user, password, pool);
            }
        
            @Override
            public Connection getConnection() {
                if (connectionPool.isEmpty()) {
                    if (usedConnections.size() < MAX_POOL_SIZE) {
                        try {
                            connectionPool.add(createConnection(url, user, password));
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                    } else throw new RuntimeException("Maximum pool size reached!");
                }
        
                Connection connection = connectionPool.remove(connectionPool.size() - 1);
        
                try {
                    if(!connection.isValid(MAX_TIMEOUT)){
                        connection = createConnection(url, user, password);
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
        
                usedConnections.add(connection);
                return connection;
            }
        
            @Override
            public boolean releaseConnection(Connection connection) {
                connectionPool.add(connection);
                return usedConnections.remove(connection);
            }
        
            @Override
            public String getUrl() {
                return url;
            }
        
            @Override
            public String getUser() {
                return user;
            }
        
            @Override
            public String getPassword() {
                return password;
            }
        
            private static Connection createConnection(String url, String user, String password) throws SQLException {
                return DriverManager.getConnection(url, user, password);
            }
        
            public int getSize() {
                return connectionPool.size() + usedConnections.size();
            }
        
            public void shutdown() throws SQLException {
                usedConnections.forEach(this::releaseConnection);
                for (Connection c : connectionPool) {
                    c.close();
                }
                connectionPool.clear();
            }
        }                            

### Custom ThreadPool               
- [Custom ThreadPool](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPool.java)                                            


        import java.util.concurrent.BlockingQueue;
        import java.util.concurrent.LinkedBlockingQueue;
        
        public class CustomThreadPool {
        
            private BlockingQueue<Runnable> taskQueue;
            private boolean poolShutDownInitiated = false;
        
            public CustomThreadPool(int nThreads){
                taskQueue = new LinkedBlockingQueue<>(nThreads);
        
                for(int i=1; i<=nThreads; i++){
                    ThreadPoolsThread threadPoolsThread=new ThreadPoolsThread(taskQueue,this);
                    threadPoolsThread.setName("Thread-"+i);
                    threadPoolsThread.start();
                }
            }
        
            public synchronized void  execute(Runnable task) throws Exception{
                if(this.poolShutDownInitiated)
                    throw new Exception("ThreadPool has been shutDown, no further tasks can be added");
        
                this.taskQueue.put(task);
            }
        
            public boolean isPoolShutDownInitiated() {
                return poolShutDownInitiated;
            }
        
            public synchronized void shutdown(){
                this.poolShutDownInitiated = true;
                System.out.println("ThreadPool SHUTDOWN initiated.");
            }
        }
        
        class ThreadPoolsThread extends Thread {
        
            private BlockingQueue<Runnable> taskQueue;
            private CustomThreadPool threadPool;
        
            public ThreadPoolsThread(BlockingQueue<Runnable> queue, CustomThreadPool threadPool){
                taskQueue = queue;
                this.threadPool=threadPool;
            }
        
            public void run() {
                try {
                    while (true) {
                        Runnable runnable = taskQueue.take();
                        runnable.run();
                        if(this.threadPool.isPoolShutDownInitiated() &&  this.taskQueue.size()==0){
                            this.interrupt();
                            Thread.sleep(1);
                        }
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName()+" has been STOPPED.");
                }
            }
        } 
        
        // Driver code
        class Task implements Runnable{
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        
        public class CustomThreadPoolTest {
            public static void main(String[] args) throws Exception {
                CustomThreadPool threadPool = new CustomThreadPool(2); //create 2 threads in ThreadPool
                Runnable task = new Task();
                threadPool.execute(task);
                threadPool.execute(task);
        
                threadPool.shutdown();
            }
        }
    
### Custom ThreadPoolExecutor               
- [Custom ThreadPoolExecutor](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomThreadPoolExecutor.java)                            


        import java.util.concurrent.BlockingQueue;
        import java.util.concurrent.LinkedBlockingQueue;
        
        public class CustomThreadPoolExecutor {
        //    https://www.javacodemonk.com/implement-custom-thread-pool-in-java-without-executor-framework-ca10e61d
        
            private final BlockingQueue<Runnable> workerQueue;
            private final Thread[] workerThreads;
        
            public CustomThreadPoolExecutor(int numThreads) {
                workerQueue = new LinkedBlockingQueue<>();
                workerThreads = new Thread[numThreads];
                int i = 0;
                for (Thread t : workerThreads) {
                    t = new Worker("Custom Pool Thread " + ++i);
                    t.start();
                }
            }
        
            public void addTask(Runnable r) {
                try {
                    workerQueue.put(r);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        
            class Worker extends Thread {
                public Worker(String name) {
                    super(name);
                }
        
                public void run() {
                    while (true) {
                        try {
                            workerQueue.take().run();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        
            public static void main(String[] args) {
                CustomThreadPoolExecutor threadPoolExecutor = new CustomThreadPoolExecutor(10);
                threadPoolExecutor.addTask(() -> System.out.println("First print task"));
                threadPoolExecutor.addTask(() -> System.out.println("Second print task"));
            }
        }
        
### Custom CountDownLatch               
- [Custom CountDownLatch](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CountdownLatchCustom.java)                                    


        public class CountdownLatchCustom {
            private int count;
        
            public CountdownLatchCustom(int count) {
                this.count=count;
            }
        
            public synchronized void await() throws InterruptedException {
                if(count>0) this.wait();
            }
        
            public synchronized void countDown() {
                count--;
                if(count == 0) this.notify();
            }
        
        }

### Custom CyclicBarrier                
- [Custom CyclicBarrier](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CyclicBarrierCustom.java)                                      


        public class CyclicBarrierCustom{
            int initialParties; //total parties
            int partiesAwait; //parties yet to arrive
            Runnable cyclicBarrrierEvent;
        
            public CyclicBarrierCustom(int parties, Runnable cyclicBarrrierEvent) {
                initialParties=parties;
                partiesAwait=parties;
                this.cyclicBarrrierEvent=cyclicBarrrierEvent;
            }
        
            public synchronized void await() throws InterruptedException {
                partiesAwait--;
                if(partiesAwait>0){
                    this.wait();
                } else{
                    partiesAwait=initialParties;
                    notifyAll(); //notify all waiting threads
                    cyclicBarrrierEvent.run(); //launch event
                }
            }
        }

- [Custom Semaphore](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/SemaphoreCustom.java)                                              


        public class SemaphoreCustom {
        
            int permits;
            public SemaphoreCustom(int permits) {
                this.permits = permits;
            }
        
            public synchronized void release() {
                permits++;
                if (permits>0) this.notifyAll();
            }
        
            public synchronized void acquire() throws InterruptedException {
                if (permits < 1) this.wait();
                permits--;
            }
        }
     
- [Custom ReentrantLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantLockCustom.java)                                      


        interface LockCustom {
            void lock();
            void unlock();
            boolean tryLock();
        }
        
        public class ReentrantLockCustom implements LockCustom {
            int lockHoldCount;
            long IdOfThreadCurrentlyHoldingLock;
        
            ReentrantLockCustom(){
                lockHoldCount=0;
            }
        
            public synchronized void lock() {
                if(lockHoldCount==0){
                    lockHoldCount++;
                    IdOfThreadCurrentlyHoldingLock=Thread.currentThread().getId();
                } else if(lockHoldCount>0 && IdOfThreadCurrentlyHoldingLock==Thread.currentThread().getId()){
                    lockHoldCount++;
                } else{
                    try {
                        wait();
                        lockHoldCount++;
                        IdOfThreadCurrentlyHoldingLock=Thread.currentThread().getId();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        
            public synchronized void unlock() {
                if(lockHoldCount==0) throw new IllegalMonitorStateException();
                lockHoldCount--; //decrement lock hold count by 1
                if(lockHoldCount==0)     notify();
            }
        
            public synchronized boolean tryLock(){
                if(lockHoldCount==0){
                    lock();
                    return true;
                } else
                    return false;
            }
        }

- [Custom ReentrantReadWriteLock](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ReentrantReadWriteLock.java)                          


        interface ReadWriteLock {
            ReentrantReadWriteLock.WriteLock writeLock();
            ReentrantReadWriteLock.ReadLock  readLock();
        }
        
        public class ReentrantReadWriteLock implements ReadWriteLock {
            private int readLockCount;
            private int writeLockCount;
            private final ReentrantReadWriteLock.ReadLock readerLock;
            private final ReentrantReadWriteLock.WriteLock writerLock;
        
            public ReentrantReadWriteLock.WriteLock writeLock() {
                return writerLock;
            }
            public ReentrantReadWriteLock.ReadLock  readLock()  {
                return readerLock;
            }
        
            public ReentrantReadWriteLock() {
                readerLock = new ReadLock();
                writerLock = new WriteLock();
            }
        
            public class ReadLock{
                public synchronized void lock() {
                    if(writeLockCount==0){
                        readLockCount++;
                    } else{
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        
                public synchronized void unlock() {
                    readLockCount--; //decrement readLockCount.
                    if(readLockCount==0)
                        notify();
                }
            }
        
            public class WriteLock{
                public synchronized void lock() {
                    if(writeLockCount==0 && readLockCount==0){
                        writeLockCount++;
                    } else{
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        
                public synchronized void unlock() {
                    writeLockCount--; //decrement writeLockCount.
                    notify(); //notify all waiting threads.
                }
            }
}
                  
- [Producer Consumer BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerBlockingQueue.java)                 


        import java.util.concurrent.BlockingQueue;
        import java.util.concurrent.LinkedBlockingQueue;
        
        class Producer implements Runnable {
            private final BlockingQueue<Integer> sharedQueue;
        
            public Producer(BlockingQueue<Integer> sharedQueue) {
                this.sharedQueue = sharedQueue;
            }
        
            @Override
            public void run() {
                for(int i=1; i<=10; i++){
                    try {
                        sharedQueue.put(i);
                    } catch (InterruptedException ex) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
        
        class Consumer implements Runnable{
            private BlockingQueue<Integer> sharedQueue;
        
            public Consumer (BlockingQueue<Integer> sharedQueue) {
                this.sharedQueue = sharedQueue;
            }
        
            @Override
            public void run() {
                while(true){
                    try {
                        System.out.println("CONSUMED : "+ sharedQueue.take());
                    } catch (InterruptedException ex) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
        
        public class ProducerConsumerBlockingQueue {
            public static void main(String args[]){
                BlockingQueue<Integer> sharedQueue = new LinkedBlockingQueue<>();
        
                Producer producer=new Producer(sharedQueue);
                Consumer consumer=new Consumer(sharedQueue);
        
                Thread producerThread = new Thread(producer, "ProducerThread");
                Thread consumerThread = new Thread(consumer, "ConsumerThread");
                producerThread.start();
                consumerThread.start();
            }
        } 
                  
- [Producer Consumer WaitNotify](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ProducerConsumerWaitNotify.java)                       


        import java.util.LinkedList;
        import java.util.List;
        
        class Producer2 implements Runnable {
            private List<Integer> sharedQueue;
            private int maxSize=2;
        
            public Producer2(List<Integer> sharedQueue) {
                this.sharedQueue = sharedQueue;
            }
        
            @Override
            public void run() {
                for (int i = 1; i <= 10; i++) {  //produce 10 products.
                    try {
                        produce(i);
                    } catch (InterruptedException e) {  e.printStackTrace();   }
                }
            }
        
            private void produce(int i) throws InterruptedException {
                synchronized (sharedQueue) {
                    while (sharedQueue.size() == maxSize) {
                        sharedQueue.wait();
                    }
                }
        
                synchronized (sharedQueue) {
                    sharedQueue.add(i);
                    Thread.sleep((long)(Math.random() * 1000));
                    sharedQueue.notify();
                }
            }
        }
        
        class Consumer2 implements Runnable {
            private List<Integer> sharedQueue;
            public Consumer2(List<Integer> sharedQueue) {
                this.sharedQueue = sharedQueue;
            }
        
            @Override
            public void run() {
                while (true) {
                    try {
                        consume();
                        Thread.sleep(100);
                    } catch (InterruptedException e) {  e.printStackTrace();   }
                }
            }
        
            private void consume() throws InterruptedException {
                synchronized (sharedQueue) {
                    while (sharedQueue.size() == 0) {
                        sharedQueue.wait();
                    }
                }
        
                synchronized (sharedQueue) {
                    Thread.sleep((long)(Math.random() * 2000));
                    System.out.println("CONSUMED : "+ sharedQueue.remove(0));
                    sharedQueue.notify();
                }
            }
        }
        
        public class ProducerConsumerWaitNotify {
        
            public static void main(String args[]) {
                List<Integer> sharedQueue = new LinkedList<>();
        
                Producer2 producer= new Producer2(sharedQueue);
                Consumer2 consumer= new Consumer2(sharedQueue);
        
                Thread producerThread = new Thread(producer, "ProducerThread");
                Thread consumerThread = new Thread(consumer, "ConsumerThread");
                producerThread.start();
                consumerThread.start();
            }
        }
        
- [LRU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LRUCache146_V2.java)                                        


        import java.util.HashMap;
        import java.util.Map;
        
        public class LRUCache146_V2 {
        //    https://leetcode.com/problems/lru-cache/discuss/640199/Java%3A-3-in-1-solution(LinkedList%2BHashMap-OR-LinkedHashMap-OR-Custom-LinkedList-%2B-HashMap)/549072/
            class Node {
                int key;
                int value;
                Node next;
                Node prev;
                Node(int key, int value ) {
                    this.key=key;
                    this.value=value;
                }
            }
        
            Node head = new Node(-1, -1);
            Node tail = new Node(-1, -1);
            private int capacity;
            Map<Integer, Node> map = new HashMap<>();
        
            public LRUCache146_V2(int capacity) {
                this.capacity=capacity;
                head.next=tail;
                tail.prev= head;
            }
        
            public int get(int key) {
                if(map.containsKey(key)) {
                    Node curr = map.get(key);
                    delete(curr);
                    setListHead(curr);
                    return curr.value;
                }
                return -1;
            }
        
            public void put(int key, int value) {
                if(map.containsKey(key)) {
                    Node curr = map.get(key);
                    curr.value = value;
                    delete(curr);
                    setListHead(curr);
                } else {
                    if(map.size()==capacity) delete(tail.prev);
                    setListHead(new Node(key, value));
                }
            }
        
            //setListHead received node after head
            private void setListHead(Node node) {
                map.put(node.key, node);
                Node headNext = head.next;
                node.next=headNext;
                headNext.prev = node;
        
                head.next=node;
                node.prev = head;
            }
        
            //delete received node
                private void delete(Node node) {
                map.remove(node.key);
                Node nodeNext = node.next;
                Node prev = node.prev;
        
                prev.next= nodeNext;
                nodeNext.prev=prev;
            }
        }

- [HashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/DesignHashMap706.java)                                        


        public class DesignHashMap706 {
            class Node {
                int key;
                int val;
                Node next;
                Node (int key, int value) {
                    this.key = key;
                    this.val = value;
                    this.next = null;
                }
            }
            Node[] nodes;
            int length;
        
            /** Initialize your data structure here. */
            public DesignHashMap706() {
                nodes = new Node[10000];
                length = nodes.length;
            }
        
            int hashCode(int key) {
                return key % length;
            }
        
            Node find(Node bucket, int key) {
                Node curr = bucket, prev = null;
                while (curr != null) {
                    if (curr.key == key) {
                        break;
                    }
                    prev = curr;
                    curr = curr.next;
                }
                return prev;
            }
        
            /** value will always be non-negative. */
            public void put(int key, int value) {
                int idx = hashCode(key);
                if (nodes[idx] == null) {
                    nodes[idx] = new Node(-1, -1);
                }
                Node prev = find(nodes[idx], key);
        
                if (prev.next == null) {
                    prev.next = new Node(key, value);
                } else {
                    prev.next.val = value;
                }
            }
        
            /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
            public int get(int key) {
                int idx = hashCode(key);
                if (nodes[idx] == null) {
                    return -1;
                }
                Node prev = find(nodes[idx], key);
        
                if (prev.next != null) {
                    return prev.next.val;
                }
                return -1;
        
            }
        
            /** Removes the mapping of the specified value key if this map contains a mapping for the key */
            public void remove(int key) {
                int idx = hashCode(key);
                if (nodes[idx] == null) {
                    return;
                }
                Node prev = find(nodes[idx], key);
        
                if (prev.next != null) {
                    prev.next = prev.next.next;
                }
            }
        }

- [LFU Cache](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/LFUCache460_V2.java)                        


        import java.util.HashMap;
        import java.util.LinkedHashSet;
        
        public class LFUCache460_V2 {
        //    https://leetcode.com/problems/lfu-cache/discuss/94515/Java-O(1)-Accept-Solution-Using-HashMap-DoubleLinkedList-and-LinkedHashSet
        
            private Node head = null;
            private int cap = 0;
            private HashMap<Integer, Integer> valueHash = null;
            private HashMap<Integer, Node> nodeHash = null;
        
            public LFUCache460_V2(int capacity) {
                this.cap = capacity;
                valueHash = new HashMap<Integer, Integer>();
                nodeHash = new HashMap<Integer, Node>();
            }
        
            public int get(int key) {
                if (valueHash.containsKey(key)) {
                    increaseCount(key);
                    return valueHash.get(key);
                }
                return -1;
            }
        
            public void put(int key, int value) {
                if ( cap == 0 ) return;
                if (valueHash.containsKey(key)) {
                    valueHash.put(key, value);
                } else {
                    if (valueHash.size() < cap) {
                        valueHash.put(key, value);
                    } else {
                        removeOld();
                        valueHash.put(key, value);
                    }
                    addToHead(key);
                }
                increaseCount(key);
            }
        
            private void addToHead(int key) {
                if (head == null) {
                    head = new Node(0);
                    head.keys.add(key);
                } else if (head.count > 0) {
                    Node node = new Node(0);
                    node.keys.add(key);
                    node.next = head;
                    head.prev = node;
                    head = node;
                } else {
                    head.keys.add(key);
                }
                nodeHash.put(key, head);
            }
        
            private void increaseCount(int key) {
                Node node = nodeHash.get(key);
                node.keys.remove(key);
        
                if (node.next == null) {
                    node.next = new Node(node.count+1);
                    node.next.prev = node;
                    node.next.keys.add(key);
                } else if (node.next.count == node.count+1) {
                    node.next.keys.add(key);
                } else {
                    Node tmp = new Node(node.count+1);
                    tmp.keys.add(key);
                    tmp.prev = node;
                    tmp.next = node.next;
                    node.next.prev = tmp;
                    node.next = tmp;
                }
        
                nodeHash.put(key, node.next);
                if (node.keys.size() == 0) remove(node);
            }
        
            private void removeOld() {
                if (head == null) return;
                int old = 0;
                for (int n: head.keys) {
                    old = n;
                    break;
                }
                head.keys.remove(old);
                if (head.keys.size() == 0) remove(head);
                nodeHash.remove(old);
                valueHash.remove(old);
            }
        
            private void remove(Node node) {
                if (node.prev == null) {
                    head = node.next;
                } else {
                    node.prev.next = node.next;
                }
                if (node.next != null) {
                    node.next.prev = node.prev;
                }
            }
        
            class Node {
                public int count = 0;
                public LinkedHashSet<Integer> keys = null;
                public Node prev = null, next = null;
        
                public Node(int count) {
                    this.count = count;
                    keys = new LinkedHashSet<Integer>();
                    prev = next = null;
                }
            }
        
        }

- [Min Stack](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/data-structures/src/MinStack155.java)                       


        public class MinStack155 {
            private Node head;
        
            public void push(int x) {
                if (head == null)
                    head = new Node(x, x, null);
                else
                    head = new Node(x, Math.min(x, head.min), head);
            }
        
            public void pop() {
                head = head.next;
            }
        
            public int top() {
                return head.val;
            }
        
            public int getMin() {
                return head.min;
            }
        
            private class Node {
                int val;
                int min;
                Node next;
        
                private Node(int val, int min, Node next) {
                    this.val = val;
                    this.min = min;
                    this.next = next;
                }
            }
        }

- [Stack Using Queues](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/StackUsingQueues_225.java)                         


        import java.util.LinkedList;
        import java.util.Queue;
        
        public class StackUsingQueues_225 {
        //Just use a queue where you "push to front" by pushing to back and then rotating the queue until the new element is at the front(i.e., size-1 times move the front element to the back).
        // https://leetcode.com/problems/implement-stack-using-queues/discuss/62516/Concise-1-Queue-Java-C%2B%2B-Python
            private Queue<Integer> queue = new LinkedList<>();
        
            public void push(int x) {
                queue.add(x);
                for (int i=1; i<queue.size(); i++)
                    queue.add(queue.remove());
            }
        
            public int pop() {
                return queue.remove();
            }
        
            public int top() {
                return queue.peek();
            }
        
            public boolean empty() {
                return queue.isEmpty();
            }
        
        }

- [Queue Using Stack](https://github.com/dxjoshi/leetcode/blob/9228b4378d7d70c8b397c3b4af38aab5e3b2dd75/data-structures/src/QueueUsingStack_232.java)                               


        import java.util.Stack;
        
        public class QueueUsingStack_232 {
            // https://leetcode.com/problems/implement-queue-using-stacks/discuss/64206/Short-O(1)-amortized-C%2B%2B-Java-Ruby
        
            Stack<Integer> input = new Stack();
            Stack<Integer> output = new Stack();
        
            public void push(int x) {
                input.push(x);
            }
        
            public int pop() {
                int x = peek();
                output.pop();
                return x;
            }
        
            public int peek() {
                if (output.empty())
                    while (!input.empty())
                        output.push(input.pop());
                return output.peek();
            }
        
            public boolean empty() {
                return input.empty() && output.empty();
            }
        }

- [Custom ArrayList](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/ArrayListCustom.java)                                          


        import java.util.Arrays;
        
        class CustomArrayList<E> {
            private static final int INITIAL_CAPACITY = 10;
            private int size = 0;
            private Object elementData[] = {};
        
            public CustomArrayList() {
                elementData = new Object[INITIAL_CAPACITY];
            }
        
            public void add(E e) {
                if (size == elementData.length) ensureCapacity(); // increase current capacity of list, make it double.
                elementData[size++] = e;
            }
        
            public E get(int index) {
                if (index < 0 || index >= size) throw new IndexOutOfBoundsException("Index: " + index + ", size " + index);
                return (E) elementData[index]; // return value on index.
            }
        
            public Object remove(int index) {
                if (index < 0 || index >= size) throw new IndexOutOfBoundsException("Index: " + index + ", size " + index);
        
                Object removedElement = elementData[index];
                for (int i = index; i < size - 1; i++) {
                    elementData[i] = elementData[i + 1];
                }
                size--; // reduce size of CustomArrayList after removal of element.
                return removedElement;
            }
        
            private void ensureCapacity() {
                int newIncreasedCapacity = elementData.length * 2;
                elementData = Arrays.copyOf(elementData, newIncreasedCapacity);
            }
        
            public void display() {
                System.out.print("Displaying list : ");
                for (int i = 0; i < size; i++) System.out.print(elementData[i] + " ");
            }
        }
        
        public class ArrayListCustom {
            public static void main(String[] args) {
                CustomArrayList<Integer> list = new CustomArrayList<Integer>();
                list.add(1);list.add(2);list.add(3);list.add(4);list.add(1);list.add(2);
        
                list.display();
                System.out.println("\nelement at index in custom ArrayList > " + 1 + " = " + list.get(1));
                System.out.println("element removed from index " + 1 + " = " + list.remove(1));
                System.out.println("\nlet's display custom ArrayList again after removal at index 1");
                list.display();
        
                // list.remove(11); //will throw IndexOutOfBoundsException, because
                // there is no element to remove on index 11.
                // list.get(11); //will throw IndexOutOfBoundsException, because there
                // is no element to get on index 11.
            }
        }

- [Custom BlockingQueue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/BlockingQueueCustomTest.java)                          


        import java.util.LinkedList;
        import java.util.List;
        
        interface BlockingQueueCustom<E> {
            void put(E item)  throws InterruptedException ;
            E take()  throws InterruptedException;
        }
        
        class LinkedBlockingQueueCustom<E> implements BlockingQueueCustom<E>{
            private List<E> queue;
            private int  maxSize ;
        
            public LinkedBlockingQueueCustom(int maxSize){
                this.maxSize = maxSize;
                queue = new LinkedList<E>();
            }
        
            public synchronized void put(E item)  throws InterruptedException  {
                if (queue.size() == maxSize) this.wait();
        
                queue.add(item);
                this.notifyAll();
            }
        
            public synchronized E take()  throws InterruptedException{
                if (queue.size() == 0) this.wait();
        
                this.notifyAll();
                return queue.remove(0);
            }
        }
        
        public class BlockingQueueCustomTest{
            public static void main(String[] args) throws InterruptedException {
                BlockingQueueCustom<Integer> b = new LinkedBlockingQueueCustom<>(10);
                System.out.println("put(11)");
                b.put(11);
                System.out.println("put(12)");
                b.put(12);
                System.out.println("take() > "+b.take());
                System.out.println("take() > "+b.take());
            }
        }
        
- [Custom Dequeue](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomDequeue.java)                          


        class CircularDequeue_641 {
            // https://leetcode.com/problems/design-circular-deque/discuss/149371/Java-doubly-LinkedList-solution-very-straightforward
            // https://leetcode.com/problems/design-circular-deque/discuss/161228/Straightforward-w-Array-in-Java(corner-cases)
        
            class DoublyLinkedList{
                DoublyLinkedList prev;
                DoublyLinkedList next;
                int val;
                DoublyLinkedList(int val){
                    this.val = val;
                }
            }
        
            DoublyLinkedList head;
            DoublyLinkedList tail;
            int k;
            int size;
        
            public CircularDequeue_641(int k) {
                head = new DoublyLinkedList(-1);
                tail = new DoublyLinkedList(-1);
                head.next = tail;
                tail.prev = head;
                this.k = k;
                this.size = size;
            }
        
            /** Adds an item at the front of Deque. Return true if the operation is successful. */
            public boolean insertFront(int value) {
                if(size == k) return false;
                DoublyLinkedList temp = new DoublyLinkedList(value);
                DoublyLinkedList curr = head.next;
                head.next = temp;
                temp.prev = head;
                temp.next = curr;
                curr.prev = temp;
                size += 1;
                return true;
            }
        
            /** Adds an item at the rear of Deque. Return true if the operation is successful. */
            public boolean insertLast(int value) {
                if(size == k) return false;
                DoublyLinkedList temp = new DoublyLinkedList(value);
                DoublyLinkedList curr = tail.prev;
                temp.next = tail;
                tail.prev = temp;
                curr.next = temp;
                temp.prev = curr;
                size += 1;
                return true;
            }
        
            /** Deletes an item from the front of Deque. Return true if the operation is successful. */
            public boolean deleteFront() {
                if(size == 0) return false;
        
                DoublyLinkedList curr = head.next;
                head.next = curr.next;
                head.next.prev = head;
                size -= 1;
                return true;
            }
        
            /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
            public boolean deleteLast() {
                if(size == 0) return false;
        
                DoublyLinkedList curr = tail.prev;
                tail.prev = curr.prev;
                tail.prev.next= tail;
                size -= 1;
                return true;
            }
        
            /** Get the front item from the deque. */
            public int getFront() {
                if(size == 0) return -1;
        
                return head.next.val;
        
            }
        
            /** Get the last item from the deque. */
            public int getRear() {
                if(size == 0) return -1;
                return tail.prev.val;
            }
        
            /** Checks whether the circular deque is empty or not. */
            public boolean isEmpty() {
                return size == 0;
            }
        
            /** Checks whether the circular deque is full or not. */
            public boolean isFull() {
                return size == k;
            }
        
        }

- [Custom HashSet](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomHashSet.java)                              

        
        class HashSetCustom<E>{
            private HashMapCustom<E, Object> hashMapCustom;
        
            public HashSetCustom(){
                hashMapCustom=new HashMapCustom<>();
            }
        
            public void add(E value){
                hashMapCustom.put(value, null);
            }
        
            public boolean contains(E obj){
                return hashMapCustom.contains(obj) !=null ? true :false;
            }
        
            public void display(){
                hashMapCustom.displaySet();
            }
        
            public boolean remove(E obj){
                return hashMapCustom.remove(obj);
            }
        }
        
        public class CustomHashSet {
            public static void main(String[] args) {
                HashSetCustom<Integer> hashSetCustom = new HashSetCustom<Integer>();
                hashSetCustom.add(21);
                hashSetCustom.add(25);
                hashSetCustom.add(30);
                hashSetCustom.add(33);
                hashSetCustom.add(35);
        
                System.out.println("HashSetCustom contains 21 ="+hashSetCustom.contains(21));
                System.out.println("HashSetCustom contains 51 ="+hashSetCustom.contains(51));
        
                System.out.print("Displaying HashSetCustom: ");
                hashSetCustom.display();
        
                System.out.println("\n\n21 removed: "+hashSetCustom.remove(21));
                System.out.println("22 removed: "+hashSetCustom.remove(22));
        
                System.out.print("Displaying HashSetCustom: ");
                hashSetCustom.display();
        
            }
        }

- [Custom LinkedHashMap](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomLinkedHashMap.java)                                      


        class LinkedHashMapCustom<K, V> {
        
            private Entry<K,V>[] table;   //Array of Entry.
            private int capacity= 4;  //Initial capacity of HashMap
            private Entry<K,V> header; //head of the doubly linked list.
            private Entry<K,V> last; //last of the doubly linked list.
        
            static class Entry<K, V> {
                K key;
                V value;
                Entry<K,V> next;
                Entry<K,V> before;
                Entry<K,V> after;
        
                public Entry(K key, V value, Entry<K,V> next){
                    this.key = key;
                    this.value = value;
                    this.next = next;
                }
            }
        
        
            public LinkedHashMapCustom(){
                table = new Entry[capacity];
            }
        
            public void put(K newKey, V data){
                if(newKey==null) return;    //does not allow to store null.
        
                int hash=hash(newKey);
                Entry<K,V> newEntry = new Entry<K,V>(newKey, data, null);
                maintainOrderAfterInsert(newEntry);
                if(table[hash] == null){
                    table[hash] = newEntry;
                }else{
                    Entry<K,V> previous = null;
                    Entry<K,V> current = table[hash];
                    while(current != null){ //we have reached last entry of bucket.
                        if(current.key.equals(newKey)){
                            if(previous==null){  //node has to be insert on first of bucket.
                                newEntry.next=current.next;
                                table[hash]=newEntry;
                                return;
                            }
                            else{
                                newEntry.next=current.next;
                                previous.next=newEntry;
                                return;
                            }
                        }
                        previous=current;
                        current = current.next;
                    }
                    previous.next = newEntry;
                }
            }
        
            private void maintainOrderAfterInsert(Entry<K, V> newEntry) {
                if(header==null){
                    header=newEntry;
                    last=newEntry;
                    return;
                }
        
                if(header.key.equals(newEntry.key)){
                    deleteFirst();
                    insertFirst(newEntry);
                    return;
                }
        
                if(last.key.equals(newEntry.key)){
                    deleteLast();
                    insertLast(newEntry);
                    return;
                }
        
                Entry<K, V> beforeDeleteEntry=    deleteSpecificEntry(newEntry);
                if(beforeDeleteEntry==null){
                    insertLast(newEntry);
                } else{
                    insertAfter(beforeDeleteEntry,newEntry);
                }
            }
        
            private void maintainOrderAfterDeletion(Entry<K, V> deleteEntry) {
        
                if(header.key.equals(deleteEntry.key)){
                    deleteFirst();
                    return;
                }
        
                if(last.key.equals(deleteEntry.key)){
                    deleteLast();
                    return;
                }
        
                deleteSpecificEntry(deleteEntry);
        
            }
        
            private void insertAfter(Entry<K, V> beforeDeleteEntry, Entry<K, V> newEntry) {
                Entry<K, V> current=header;
                while(current!=beforeDeleteEntry){
                    current=current.after;  //move to next node.
                }
        
                newEntry.after=beforeDeleteEntry.after;
                beforeDeleteEntry.after.before=newEntry;
                newEntry.before=beforeDeleteEntry;
                beforeDeleteEntry.after=newEntry;
        
            }
        
            void deleteFirst(){
                if(header==last){ //only one entry found.
                    header=last=null;
                    return;
                }
                header=header.after;
                header.before=null;
            }
        
            void insertFirst(Entry<K, V> newEntry){
        
                if(header==null){ //no entry found
                    header=newEntry;
                    last=newEntry;
                    return;
                }
        
                newEntry.after=header;
                header.before=newEntry;
                header=newEntry;
        
            }
        
            void insertLast(Entry<K, V> newEntry){
        
                if(header==null){
                    header=newEntry;
                    last=newEntry;
                    return;
                }
                last.after=newEntry;
                newEntry.before=last;
                last=newEntry;
        
            }
        
            void deleteLast(){
                if(header==last){
                    header=last=null;
                    return;
                }
                last=last.before;
                last.after=null;
            }
        
            private Entry<K, V> deleteSpecificEntry(Entry<K, V> newEntry){
                Entry<K, V> current=header;
                while(!current.key.equals(newEntry.key)){
                    if(current.after==null) return null;    //entry not found
                    current=current.after;  //move to next node.
                }
        
                Entry<K, V> beforeDeleteEntry=current.before;
                current.before.after=current.after;
                current.after.before=current.before;  //entry deleted
                return beforeDeleteEntry;
            }
        
            public V get(K key){
                int hash = hash(key);
                if(table[hash] == null){
                    return null;
                }else{
                    Entry<K,V> temp = table[hash];
                    while(temp!= null){
                        if(temp.key.equals(key))
                            return temp.value;
                        temp = temp.next; //return value corresponding to key.
                    }
                    return null;   //returns null if key is not found.
                }
            }
        
            public boolean remove(K deleteKey){
                int hash=hash(deleteKey);
        
                if(table[hash] == null){
                    return false;
                }else{
                    Entry<K,V> previous = null;
                    Entry<K,V> current = table[hash];
        
                    while(current != null){ //we have reached last entry node of bucket.
                        if(current.key.equals(deleteKey)){
                            maintainOrderAfterDeletion(current);
                            if(previous==null){  //delete first entry node.
                                table[hash]=table[hash].next;
                                return true;
                            }
                            else{
                                previous.next=current.next;
                                return true;
                            }
                        }
                        previous=current;
                        current = current.next;
                    }
                    return false;
                }
        
            }
        
            public void display(){
                Entry<K, V> currentEntry=header;
                while(currentEntry!=null){
                    System.out.print("{"+currentEntry.key+"="+currentEntry.value+"}" +" ");
                    currentEntry=currentEntry.after;
                }
            }
        
            private int hash(K key){
                return Math.abs(key.hashCode()) % capacity;
            }
        
            public K contains(K key){
                int hash = hash(key);
                if(table[hash] == null){
                    return null;
                }else{
                    Entry<K,V> temp = table[hash];
                    while(temp!= null){
                        if(temp.key.equals(key))
                            return key;
                        temp = temp.next; //return value corresponding to key.
                    }
                    return null;   //returns null if key is not found.
                }
            }
        
            public void displaySet(){
                Entry<K, V> currentEntry=header;
                while(currentEntry!=null){
                    System.out.print(currentEntry.key+" ");
                    currentEntry=currentEntry.after;
                }
            }
        }
        
        public class CustomLinkedHashMap {
            public static void main(String[] args) {
                LinkedHashMapCustom<Integer, Integer> linkedHashMapCustom = new LinkedHashMapCustom<Integer, Integer>();
        
                linkedHashMapCustom.put(21, 12);
                linkedHashMapCustom.put(25, 121);
                linkedHashMapCustom.put(30, 151);
                linkedHashMapCustom.put(33, 15);
                linkedHashMapCustom.put(35, 89);
        
                System.out.println("Display values corresponding to keys>");
                System.out.println("value corresponding to key 21=" + linkedHashMapCustom.get(21));
                System.out.println("value corresponding to key 51=" + linkedHashMapCustom.get(51));
        
                System.out.print("Displaying : ");
                linkedHashMapCustom.display();
        
                System.out.println("\n\nvalue corresponding to key 21 removed: " + linkedHashMapCustom.remove(21));
                System.out.println("value corresponding to key 22 removed: " + linkedHashMapCustom.remove(22));
        
                System.out.print("Displaying : ");
                linkedHashMapCustom.display();
            }
        }
 
- [Custom LinkedHashSet](https://github.com/dxjoshi/leetcode/blob/0653ff88be0c51b9e2b6337b271caad0c1e54415/custom-implementation/src/CustomLinkedHashSet.java)                                      


        class LinkedHashSetCustom<E>{
            private LinkedHashMapCustom<E, Object> linkedHashMapCustom;
        
            public LinkedHashSetCustom(){
                linkedHashMapCustom=new LinkedHashMapCustom<>();
            }
        
            public void add(E value){
                linkedHashMapCustom.put(value, null);
            }
        
            public boolean contains(E obj){
                return linkedHashMapCustom.contains(obj) !=null ? true :false;
            }
        
            public void display(){
                linkedHashMapCustom.displaySet();
            }
        
            public boolean remove(E obj){
                return linkedHashMapCustom.remove(obj);
            }
        }
        
        public class CustomLinkedHashSet {
            public static void main(String[] args) {
                LinkedHashSetCustom<Integer> linkedHashSetCustom = new LinkedHashSetCustom<Integer>();
                linkedHashSetCustom.add(21);
                linkedHashSetCustom.add(25);
                linkedHashSetCustom.add(30);
                linkedHashSetCustom.add(33);
                linkedHashSetCustom.add(35);
        
                System.out.println("LinkedHashSetCustom contains 21 ="+linkedHashSetCustom.contains(21));
                System.out.println("LinkedHashSetCustom contains 51 ="+linkedHashSetCustom.contains(51));
        
                System.out.print("Displaying LinkedHashSetCustom: ");
                linkedHashSetCustom.display();
        
                System.out.println("\n\n21 removed: "+linkedHashSetCustom.remove(21));
                System.out.println("22 removed: "+linkedHashSetCustom.remove(22));
        
                System.out.print("Displaying LinkedHashSetCustom: ");
                linkedHashSetCustom.display();
        
            }
        }
 
